<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Millennium Profile</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Style for a cleaner dropdown menu */
        .rank-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236B7280%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-13%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2013l128%20127.9c3.6%203.6%207.8%205.4%2013%205.4s9.4-1.8%2013-5.4L287%2095.2c3.6%203.6%205.4-7.8%205.4-13%200-5-1.8-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 0.65em auto;
            padding-right: 2.5rem; /* Space for the arrow */
        }
        /* Style for when a select is invalid */
        .invalid-select {
            border-color: #EF4444; /* Red */
            background-color: #FEE2E2; /* Light Red */
        }
        /* D3 Chart text styling */
        .chart-label-title {
            font-size: 1.5rem; /* Tailwind text-2xl equivalent */
            font-weight: 700; /* Tailwind font-bold equivalent */
            fill: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            text-anchor: middle; /* Center text horizontally */
        }
        .chart-label-score {
            font-size: 1.25rem; /* Tailwind text-xl equivalent */
            font-weight: 500; /* Tailwind font-medium equivalent */
            fill: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            text-anchor: middle; /* Center text horizontally */
        }
        /* D3 Radar Chart text styling */
        .radar-label {
            font-size: 0.875rem; /* text-sm */
            font-weight: 600; /* font-semibold */
            text-anchor: middle;
            fill: #374151; /* gray-700 */
        }

        /* --- Drag and Drop Styles --- */
        .rank-badge {
            font-variant-numeric: tabular-nums;
        }
        /* Style for the item being dragged */
        .dragging {
            opacity: 0.5;
            background: #f0f9ff; /* light-blue-50 */
            border: 1px dashed #0284c7; /* blue-600 */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans p-4 md:p-8 min-h-screen flex items-center justify-center">

    <main id="test-page" class="container bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-3xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-3 text-blue-700">Millennium Profile</h1>
        <p class="text-center text-gray-600 mb-8">
            For each question, <strong>drag and drop</strong> the words to rank them from 1 (most like you) to 4 (least like you).
        </p>

        <p id="question-counter" class="text-center text-lg font-semibold text-gray-700 mb-4"></p>

        <div id="questions-container" class="space-y-6">
            </div>

        <div class="mt-10 flex flex-col items-center justify-center gap-4">
            
            <button id="dev-fill-button" 
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-full sm:w-auto">
                Developer: Random Fill
            </button>
            
            <div class="flex flex-row justify-center gap-4 w-full sm:w-auto">
                <button id="prev-button" 
                        class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-1/2 sm:w-auto">
                    Previous
                </button>
                <button id="next-button" 
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 w-1/2 sm:w-auto">
                    Next
                </button>
            </div>
            
            <button id="save-button" 
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto"
                    disabled style="display: none;">
                Show Results
            </button>
        </div>
        <p id="success-message" class="text-green-600 font-semibold mt-4 h-6 text-center"></p>
    </main>

    <div id="results-page" class="hidden fixed inset-0 bg-gray-100 p-4 overflow-y-auto">
        <div class="container bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-5xl mx-auto flex flex-col items-center my-auto">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-blue-700">Your Profile Results</h1>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 w-full">

                <div class="md:col-span-2 bg-gray-50 rounded-lg p-4 shadow-inner">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Quadrant Chart</h2>
                    <div id="quadrant-chart-container" class="w-full h-[60vh] overflow-hidden">
                        <svg id="quadrant-chart" class="w-full h-full"></svg>
                    </div>
                </div>

                <div class="bg-gray-50 rounded-lg p-4 shadow-inner md:col-span-2">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Radar Chart (Star)</h2>
                    <div id="radar-chart-container" class="w-full h-[50vh] overflow-hidden">
                        <svg id="radar-chart" class="w-full h-full"></svg>
                    </div>
                </div>

                <div class="bg-gray-50 rounded-lg p-4 shadow-inner md:col-span-1">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Donut Chart (Proportions)</h2>
                    <div id="donut-chart-container" class="w-full h-[50vh] overflow-hidden">
                        <svg id="donut-chart" class="w-full h-full"></svg>
                    </div>
                </div>

                <div class="bg-gray-50 rounded-lg p-4 shadow-inner md:col-span-1">
                    <h2 class="text-xl font-bold text-center text-gray-800 mb-4">Bubble Chart (Impact)</h2>
                    <div id="bubble-chart-container" class="w-full h-[50vh] overflow-hidden">
                        <svg id="bubble-chart" class="w-full h-full"></svg>
                    </div>
                </div>

            </div>
            
            <div class="text-center mt-8">
                <button id="back-to-test-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-300">
                    Back to Test
                </button>
            </div>
        </div>
    </div>


    <script>
        // --- PAGE ELEMENTS ---
        const testPage = document.getElementById('test-page');
        const resultsPage = document.getElementById('results-page');
        const questionsContainer = document.getElementById('questions-container');
        const saveButton = document.getElementById('save-button');
        const successMessage = document.getElementById('success-message');
        const backToTestButton = document.getElementById('back-to-test-button');
        const devFillButton = document.getElementById('dev-fill-button');
        
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const questionCounter = document.getElementById('question-counter');

        // --- STATE ---
        let currentQuestionIndex = 0;
        const totalQuestions = 24;

        // --- QUESTION DATA ---
        const questionsData = [
            // Q1
            [
                { word: "Gentle, Kindly", color: "green" },
                { word: "Persuasive, convincing", color: "yellow" },
                { word: "Humble, reserved", color: "blue" },
                { word: "Original, inventive", color: "red" }
            ],
            // Q2
            [
                { word: "Attractive, charming", color: "yellow" },
                { word: "Cooperative, agreeable", color: "blue" },
                { word: "Stubborn, unyielding", color: "red" },
                { word: "Pleasing, Pleasant", color: "green" }
            ],
            // Q3
            [
                { word: "Easily lead, follower", color: "blue" },
                { word: "Bold, daring", color: "red" },
                { word: "Loyal, faithful", color: "green" },
                { word: "Charming, delightful", color: "yellow" }
            ],
            // Q4
            [
                { word: "Open-minded, receptive", color: "blue" },
                { word: "Obliging, helpful", color: "green" },
                { word: "Will-strong, strong willed", color: "red" },
                { word: "Cheerful, joyful", color: "yellow" }
            ],
            // Q5
            [
                { word: "Jovial, joking", color: "yellow" },
                { word: "Precise, exact", color: "blue" },
                { word: "Gutsy, brazen", color: "red" },
                { word: "Even tempered, calm", color: "green" }
            ],
            // Q6
            [
                { word: "Competitive, seeking to win", color: "red" },
                { word: "Considerate, caring, thoughtful", color: "green" },
                { word: "Out-going, fun loving", color: "yellow" },
                { word: "Harmonious, agreeable", color: "blue" }
            ],
            // Q7
            [
                { word: "Fussy, hard to please", color: "blue" },
                { word: "Obedient, dutiful", color: "green" },
                { word: "Unconquerable, determined", color: "red" },
                { word: "Playful, full of fun", color: "yellow" }
            ],
            // Q8
            [
                { word: "Brave, courageous", color: "red" },
                { word: "Inspiring, motivating", color: "yellow" },
                { word: "Submissive, yielding", color: "green" },
                { word: "Timid, shy quiet", color: "blue" }
            ],
            // Q9
            [
                { word: "Sociable", color: "yellow" },
                { word: "Patient", color: "green" },
                { word: "Self-reliant, independent", color: "red" },
                { word: "Mild, reserved", color: "blue" }
            ],
            // Q10
            [
                { word: "Adventurous", color: "red" },
                { word: "Receptive, open to suggestions", color: "blue" },
                { word: "Warm, friendly", color: "yellow" },
                { word: "Moderate", color: "green" }
            ],
            // Q11
            [
                { word: "Talkative, chatty", color: "yellow" },
                { word: "Controlled, restrained", color: "green" },
                { word: "Conventional", color: "blue" },
                { word: "Decisive, certain", color: "red" }
            ],
            // Q12
            [
                { word: "Polished, smooth talker", color: "yellow" },
                { word: "Daring, risk-taker", color: "red" },
                { word: "Diplomatic, tactful", color: "blue" },
                { word: "Satisfied, content", color: "green" }
            ],
            // Q13
            [
                { word: "Aggressive, challenging", color: "red" },
                { word: "Outgoing, entertaining", color: "yellow" },
                { word: "Life of party, ebullient", color: "green" },
                { word: "Fearful, afraid", color: "blue" }
            ],
            // Q14
            [
                { word: "Cautious, wary", color: "blue" },
                { word: "Determined, decided", color: "red" },
                { word: "Convincing, assuring", color: "yellow" },
                { word: "Good-natured, pleasant", color: "green" }
            ],
            // Q15
            [
                { word: "Willing, compliant", color: "green" },
                { word: "Eager, anxious", color: "yellow" },
                { word: "Agreeable, Consenting", color: "blue" },
                { word: "High-spirited, lively, enthusiastic", color: "red" }
            ],
            // Q16
            [
                { word: "Confident, assured", color: "yellow" },
                { word: "Compassionate, compassionate", color: "blue" },
                { word: "Tolerant", color: "green" },
                { word: "Assertive, aggressive", color: "red" }
            ],
            // Q17
            [
                { word: "Well disciplined, self-controlled", color: "blue" },
                { word: "Generous, willing to share", color: "green" },
                { word: "Animated, uses gestures for expression", color: "yellow" },
                { word: "Persistent, unrelenting", color: "red" }
            ],
            // Q18 (Duplicate of Q8 text, but with new colors from your doc)
            [
                { word: "Brave, courageous", color: "red" },
                { word: "Inspiring, motivating", color: "yellow" },
                { word: "Submissive, yielding", color: "blue" },
                { word: "Timid, shy quiet", color: "green" }
            ],
            // Q19
            [
                { word: "Respectful", color: "blue" },
                { word: "Pioneering, exploring", color: "red" },
                { word: "Optimistic, positive", color: "yellow" },
                { word: "Accommodating, willing to please", color: "green" }
            ],
            // Q20
            [
                { word: "Argumentative, Controlling", color: "red" },
                { word: "Adaptable, flexible", color: "green" },
                { word: "Nonchalant, indifferent", color: "blue" },
                { word: "Light-hearted, carefree", color: "yellow" }
            ],
            // Q21
            [
                { word: "Trusting, faith in others", color: "yellow" },
                { word: "Contented, satisfied", color: "green" },
                { word: "Positive, sure", color: "red" },
                { word: "Peaceful, tranquil", color: "blue" }
            ],
            // Q22
            [
                { word: "Good mixer, sociable", color: "yellow" },
                { word: "Educated, Knowledgeable", color: "blue" },
                { word: "Vigorous, energetic", color: "red" },
                { word: "Lenient", color: "green" }
            ],
            // Q23
            [
                { word: "Compassionate", color: "yellow" },
                { word: "Accurate, correct", color: "blue" },
                { word: "Outspoken, speaks freely", color: "red" },
                { word: "Restrained, reserved, controlled", color: "green" }
            ],
            // Q24
            [
                { word: "Restless, unable to rest or relax", color: "red" },
                { word: "Neighborly, friendly", color: "green" },
                { word: "Popular, liked by many", color: "yellow" },
                { word: "Neat, organized", color: "blue" }
            ]
        ];

        // --- QUESTION CARD FUNCTIONS ---

        function createWordRow(word, color, rank) {
            return `
                <li class="flex justify-between items-center bg-gray-50 p-3 rounded-lg border border-gray-200 cursor-grab active:cursor-grabbing" data-color="${color}" draggable="true">
                    <div class="flex items-center">
                        <span class="rank-badge text-lg font-bold text-blue-600 w-8 text-center">${rank}.</span>
                        <svg class="w-5 h-5 text-gray-400 mx-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                        <span class="word-text text-gray-800 font-medium">${word}</span>
                    </div>
                </li>
            `;
        }

        function createQuestionCard(questionWords, index) {
            const card = document.createElement('div');
            card.className = 'question-card bg-white border border-gray-200 rounded-lg p-5 shadow-sm';
            card.dataset.questionId = index;
            card.dataset.status = 'valid'; // Assume valid initially, or change logic
            
            if (index !== 0) {
                card.style.display = 'none';
            }

            const wordRows = questionWords.map((item, i) => createWordRow(item.word, item.color, i + 1)).join('');

            card.innerHTML = `
                <h2 class="text-xl font-semibold text-gray-900 mb-4">Question ${index + 1}</h2>
                <ul class="space-y-3 drag-container">
                    ${wordRows}
                </ul>
                <div class="error-message text-red-600 text-sm font-medium mt-3 h-5"></div>
            `;
            return card;
        }

        // --- NAVIGATION FUNCTION ---

        function showQuestion(index) {
            const allCards = document.querySelectorAll('.question-card');
            allCards.forEach(card => {
                card.style.display = 'none';
            });
            if (allCards[index]) {
                allCards[index].style.display = 'block';
            }
            questionCounter.textContent = `Question ${index + 1} of ${totalQuestions}`;
            prevButton.disabled = (index === 0);
            
            if (index === totalQuestions - 1) {
                nextButton.style.display = 'none';
                saveButton.style.display = 'inline-flex';
            } else {
                nextButton.style.display = 'inline-flex';
                saveButton.style.display = 'none';
            }
            checkFormCompletion();
        }

        // --- VALIDATION FUNCTIONS ---

        function validateCard(card) {
            const errorMessage = card.querySelector('.error-message');
            if (errorMessage) {
                errorMessage.textContent = '';
            }
            card.dataset.status = 'valid';
            checkFormCompletion();
            return true;
        }

        function checkFormCompletion() {
            const allCards = document.querySelectorAll('.question-card');
            let allValid = true;
            allCards.forEach(card => {
                if (card.dataset.status !== 'valid') {
                    allValid = false;
                }
            });
            saveButton.disabled = !allValid;
        }

        // --- CALCULATION & CHARTING FUNCTIONS ---

        function calculateScores() {
            const pointMap = [10, 6, 3, 1]; 
            let scores = { blue: 0, red: 0, green: 0, yellow: 0 };
            const allCards = document.querySelectorAll('.question-card');
            
            allCards.forEach(card => {
                const rankedWords = card.querySelectorAll('li[data-color]');
                rankedWords.forEach((wordLi, index) => {
                    const color = wordLi.dataset.color;
                    const points = pointMap[index];
                    if (color && points != null) {
                        scores[color] += points;
                    }
                });
            });
            return scores;
        }

        // --- CHART 1: QUADRANT CHART ---
        function drawQuadrantChart(scores) {
            const chartContainer = document.getElementById('quadrant-chart-container');
            if (!chartContainer) return;
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight;
            
            const svg = d3.select("#quadrant-chart")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const centerX = width / 2;
            const centerY = height / 2;

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6", quadrant: 'top-left' },
                { name: "Red", value: scores.red, color: "#EF4444", quadrant: 'top-right' },
                { name: "Green", value: scores.green, color: "#22C55E", quadrant: 'bottom-left' },
                { name: "Yellow", value: scores.yellow, color: "#EAB308", quadrant: 'bottom-right' }
            ].filter(d => d.value > 0);

            if (data.length === 0) return;

            data.forEach(d => { d.side = Math.sqrt(d.value); });
            const maxSide = d3.max(data, d => d.side);
            const maxRadius = Math.min(width / 2, height / 2) * 0.95;
            const scale = maxSide > 0 ? maxRadius / maxSide : 1;

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);

            data.forEach(d => {
                const scaledSide = d.side * scale;
                let x, y, textX, textY;
                switch (d.quadrant) {
                    case 'top-left': x = -scaledSide; y = -scaledSide; textX = -scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'top-right': x = 0; y = -scaledSide; textX = scaledSide / 2; textY = -scaledSide / 2; break;
                    case 'bottom-left': x = -scaledSide; y = 0; textX = -scaledSide / 2; textY = scaledSide / 2; break;
                    case 'bottom-right': x = 0; y = 0; textX = scaledSide / 2; textY = scaledSide / 2; break;
                }

                chartGroup.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", scaledSide)
                    .attr("height", scaledSide)
                    .attr("fill", d.color);

                if (scaledSide > 60) {
                    chartGroup.append("text")
                        .attr("class", "chart-label-title")
                        .attr("x", textX)
                        .attr("y", textY - 10)
                        .text(d.name);
                    chartGroup.append("text")
                        .attr("class", "chart-label-score")
                        .attr("x", textX)
                        .attr("y", textY + 16)
                        .text(d.value);
                }
            });
        }

        // --- CHART 2: RADAR (STAR) CHART ---
        function drawRadarChart(scores) {
            const chartContainer = document.getElementById('radar-chart-container');
            if (!chartContainer) return;
            const width = chartContainer.clientWidth;
            const height = chartContainer.clientHeight;
            
            const svg = d3.select("#radar-chart")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const centerX = width / 2;
            const centerY = height / 2;

            // Data setup, matching the quadrant chart layout
            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6", quadrant: 'top-left' },
                { name: "Red", value: scores.red, color: "#EF4444", quadrant: 'top-right' },
                { name: "Green", value: scores.green, color: "#22C55E", quadrant: 'bottom-left' },
                { name: "Yellow", value: scores.yellow, color: "#EAB308", quadrant: 'bottom-right' }
            ].filter(d => d.value > 0);

            if (data.length === 0) return;

            // Calculate side = sqrt(2 * Area)
            // Area = 0.5 * side * side => side = sqrt(2 * Area)
            data.forEach(d => { d.side = Math.sqrt(2 * d.value); });
            
            // Scaling logic
            const maxSide = d3.max(data, d => d.side);
            const maxRadius = Math.min(width / 2, height / 2) * 0.95; // 95% of space
            const scale = maxSide > 0 ? maxRadius / maxSide : 1;

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);

            // Draw grid lines (axes)
            chartGroup.append("line")
                .attr("x1", -width/2).attr("y1", 0)
                .attr("x2", width/2).attr("y2", 0)
                .attr("stroke", "#cbd5e1").attr("stroke-width", 2);
            chartGroup.append("line")
                .attr("x1", 0).attr("y1", -height/2)
                .attr("x2", 0).attr("y2", height/2)
                .attr("stroke", "#cbd5e1").attr("stroke-width", 2);

            data.forEach(d => {
                const scaledSide = d.side * scale;
                let pathString = "";
                let textX = 0, textY = 0;

                switch (d.quadrant) {
                    case 'top-left': // Blue
                        pathString = `M 0,0 L ${-scaledSide},0 L 0,${scaledSide} Z`;
                        textX = -scaledSide / 3; textY = scaledSide / 3;
                        break;
                    case 'top-right': // Red
                        pathString = `M 0,0 L ${scaledSide},0 L 0,${scaledSide} Z`;
                        textX = scaledSide / 3; textY = scaledSide / 3;
                        break;
                    case 'bottom-left': // Green
                        pathString = `M 0,0 L ${-scaledSide},0 L 0,${-scaledSide} Z`;
                        textX = -scaledSide / 3; textY = -scaledSide / 3;
                        break;
                    case 'bottom-right': // Yellow
                        pathString = `M 0,0 L ${scaledSide},0 L 0,${-scaledSide} Z`;
                        textX = scaledSide / 3; textY = -scaledSide / 3;
                        break;
                }

                // Draw the triangle
                chartGroup.append("path")
                    .attr("d", pathString)
                    .attr("fill", d.color)
                    .attr("fill-opacity", 0.8);

                // Add text (Name and Score)
                // Text is placed at the centroid of the right triangle (1/3 from corner)
                if (scaledSide > 60) { // Only if triangle is big enough
                    chartGroup.append("text")
                        .attr("class", "chart-label-title")
                        .attr("x", textX)
                        .attr("y", textY - 10)
                        .text(d.name);
                    chartGroup.append("text")
                        .attr("class", "chart-label-score")
                        .attr("x", textX)
                        .attr("y", textY + 16)
                        .text(d.value);
                }
            });
        }

        // --- CHART 3: TREEMAP CHART ---
        // Removed the drawTreemapChart function as it's no longer used.

        // --- NEW CHART 3: DONUT CHART ---
        function drawDonutChart(scores) {
            const container = document.getElementById('donut-chart-container');
            if (!container) return;
            const width = container.clientWidth;
            const height = container.clientHeight;
            const radius = Math.min(width, height) / 2 * 0.9; // 90% of radius
            const innerRadius = radius * 0.6; // Donut hole size

            const svg = d3.select("#donut-chart")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const chartGroup = svg.append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            const data = [
                { name: "Blue", value: scores.blue, color: "#3B82F6" },
                { name: "Red", value: scores.red, color: "#EF4444" },
                { name: "Green", value: scores.green, color: "#22C55E" },
                { name: "Yellow", value: scores.yellow, color: "#EAB308" }
            ].filter(d => d.value > 0);

            if (data.length === 0) return;

            const total = d3.sum(data, d => d.value);

            const pie = d3.pie().value(d => d.value).sort(null); // No sorting, keep color order
            const arc = d3.arc().innerRadius(innerRadius).outerRadius(radius);

            const arcs = chartGroup.selectAll(".arc")
                .data(pie(data))
                .enter().append("g")
                .attr("class", "arc");

            arcs.append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .attr("stroke", "white")
                .style("stroke-width", "2px");

            // Add text labels (percentages)
            arcs.append("text")
                .attr("transform", d => `translate(${arc.centroid(d)})`)
                .attr("dy", "0.35em")
                .attr("fill", "white")
                .attr("text-anchor", "middle")
                .style("font-size", "1.1rem")
                .style("font-weight", "600")
                .style("text-shadow", "0 0 3px rgba(0,0,0,0.7)")
                .text(d => {
                    if (total === 0) return "0%";
                    const percent = (d.data.value / total) * 100;
                    return `${percent.toFixed(0)}%`;
                });
        }

        // --- NEW CHART 4: BUBBLE CHART ---
        function drawBubbleChart(scores) {
            const container = document.getElementById('bubble-chart-container');
            if (!container) return;
            const width = container.clientWidth;
            const height = container.clientHeight;

            const svg = d3.select("#bubble-chart")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            svg.html("");

            const filteredChildren = [
                { name: "Blue", value: scores.blue, color: "#3B82F6" },
                { name:AN: "Red", value: scores.red, color: "#EF4444" },
                { name: "Green", value: scores.green, color: "#22C55E" },
                { name: "Yellow", value: scores.yellow, color: "#EAB308" }
            ].filter(d => d.value > 0);

            if (filteredChildren.length === 0) return;

            const data = { name: "root", children: filteredChildren };

            const root = d3.hierarchy(data).sum(d => d.value).sort((a,b) => b.value - a.value);
            const pack = d3.pack().size([width, height]).padding(10); // Add padding
            pack(root);

            const node = svg.selectAll(".node")
                .data(root.leaves())
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`);

            node.append("circle")
                .attr("r", d => d.r)
                .attr("fill", d => d.data.color)
                .attr("fill-opacity", 0.8)
                .attr("stroke", d => d.data.color)
                .attr("stroke-width", 2);

            // Add text
            node.each(function(d) {
                const group = d3.select(this);
                if (d.r > 30) { // Only add text if bubble is big enough
                    group.append("text")
                        .attr("class", "chart-label-title")
                        .attr("y", -10)
                        .text(d.data.name);
                    group.append("text")
                        .attr("class", "chart-label-score")
                        .attr("y", 16)
                        .text(d.data.value);
                }
            });
        }

        // --- DRAG AND DROP FUNCTIONS ---
        let draggedItem = null;

        function updateRanks(container) {
            const items = container.querySelectorAll('li[data-color]');
            items.forEach((item, index) => {
                const rankBadge = item.querySelector('.rank-badge');
                if (rankBadge) {
                    rankBadge.textContent = `${index + 1}.`;
                }
            });
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('li[data-color]:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- INITIALIZATION & EVENT LISTENERS ---

        function initialize() {
            // Render all questions
            questionsData.forEach((words, index) => {
                const card = createQuestionCard(words, index);
                questionsContainer.appendChild(card);
            });
            
            showQuestion(currentQuestionIndex);

            // --- Drag and Drop Listeners ---
            questionsContainer.addEventListener('dragstart', (e) => {
                const li = e.target.closest('li[data-color]');
                if (li) {
                    draggedItem = li;
                    setTimeout(() => li.classList.add('dragging'), 0);
                }
            });

            questionsContainer.addEventListener('dragend', (e) => {
                if (draggedItem) {
                    draggedItem.classList.remove('dragging');
                    draggedItem = null;
                }
            });

            questionsContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                const container = e.target.closest('.drag-container');
                if (!container) return;
                const afterElement = getDragAfterElement(container, e.clientY);
                const draggable = document.querySelector('.dragging');
                if (draggable) {
                    if (afterElement == null) {
                        container.appendChild(draggable);
                    } else {
                        container.insertBefore(draggable, afterElement);
                    }
                }
            });

            questionsContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                const container = e.target.closest('.drag-container');
                if (container) {
                    updateRanks(container);
                    const card = e.target.closest('.question-card');
                    if(card) {
                        validateCard(card);
                    }
                }
            });

            // --- Button Listeners ---
            saveButton.addEventListener('click', () => {
                checkFormCompletion();
                if (!saveButton.disabled) {
                    const scores = calculateScores();
                    
                    testPage.classList.add('hidden');
                    resultsPage.classList.remove('hidden');

                    // Draw all three charts
                    setTimeout(() => {
                        drawQuadrantChart(scores);
                        drawRadarChart(scores);
                        // drawTreemapChart(scores); // <-- This is now fully removed
                        drawDonutChart(scores); // <-- ADDED
                        drawBubbleChart(scores); // <-- ADDED
                    }, 10); 

                    successMessage.textContent = 'Answers saved and results calculated!';
                    setTimeout(() => { successMessage.textContent = ''; }, 3000);
                }
            });

            backToTestButton.addEventListener('click', () => {
                resultsPage.classList.add('hidden');
                testPage.classList.remove('hidden');
            });
            
            nextButton.addEventListener('click', () => {
                if (currentQuestionIndex < totalQuestions - 1) {
                    currentQuestionIndex++;
                    showQuestion(currentQuestionIndex);
                }
            });

            prevButton.addEventListener('click', () => {
                if (currentQuestionIndex > 0) {
                    currentQuestionIndex--;
                    showQuestion(currentQuestionIndex);
                }
            });

            devFillButton.addEventListener('click', () => {
                const allCards = document.querySelectorAll('.question-card');
                allCards.forEach(card => {
                    const wordList = card.querySelector('.drag-container');
                    const items = Array.from(wordList.querySelectorAll('li[data-color]'));
                    for (let i = items.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [items[i], items[j]] = [items[j], items[i]];
                    }
                    items.forEach(item => wordList.appendChild(item));
                    updateRanks(wordList);
                    card.dataset.status = 'valid';
                    card.querySelector('.error-message').textContent = '';
                });

                successMessage.textContent = 'All answers randomly filled!';
                setTimeout(() => { successMessage.textContent = ''; }, 3000);
                
                // currentQuestionIndex = totalQuestions - 1; // <-- REMOVED
                // showQuestion(currentQuestionIndex); // <-- REMOVED
                checkFormCompletion(); // This just enables the save button
            });

            // --- Resize Listener ---
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (!resultsPage.classList.contains('hidden')) {
                        const scores = calculateScores(); 
                        // Redraw all charts
                        drawQuadrantChart(scores);
                        drawRadarChart(scores);
                        // drawTreemapChart(scores); // <-- This is now fully removed
                        drawDonutChart(scores); // <-- ADDED
                        drawBubbleChart(scores); // <-- ADDED
                    }
                }, 250);
            });
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
